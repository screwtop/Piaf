#!/usr/bin/wish

# My simple Tcl/Tk text editor/idioter.


wm title . Piaf

#puts stderr $argv

#puts stderr $env(PWD)
#puts stderr [info script]
#cd /usr/local/piaf/bin	;# Hmm, better not to [cd], in case a relative filename was given on the command line.
set ::binary_path /usr/local/piaf/bin	;# Or is it better to do something with auto_path?
# lappend auto_path $::binary_path

# TODO: handle command-line arguments (open files, perhaps additional options for e.g. batch running of scripts)


namespace eval ::piaf {}

set ::status "Starting upâ€¦"

source "$::binary_path/settings.tcl"	;# Load system-wide settings first...
catch {source ~/.piaf/settings.tcl}		;# ...then any user-defined settings.

# We use an SQLite database to keep track of recently modified files, collections of files making up projects, etc.
package require sqlite3
sqlite3 ::piaf::database ~/.piaf/data.db
# TODO: create database if necessary?
puts stderr "SQLite database opened, version [::piaf::database version]"

source "$::binary_path/menus.tcl"
# TODO: toolbar?  Separate file.

frame .editor
pack .editor -side top -expand true -fill both

# TODO: tidy up wrapping option setting.
text .editor.text -wrap word -undo true
set ::wrap_mode "Word Wrap"

# Scrollbar for the main text (on the left, dammit!):
scrollbar .editor.scrollbar -command [list .editor.text yview]
.editor.text configure -yscrollcommand [list .editor.scrollbar set]

pack .editor.text -side right -expand true -fill both
pack .editor.scrollbar -side left -fill y


# Apply font preference:
.editor.text configure -font $::font

# Apply a colour scheme:
.editor.text configure -background $::background_colour -foreground $::text_colour -selectbackground $::selectbackground_colour -insertbackground $::insertbackground_colour


# Bring in various support functionality:

source "$::binary_path/functions.tcl"	;# Text filters
source "$::binary_path/commands.tcl"	;# Editor command set
source "$::binary_path/statusbar.tcl"
source "$::binary_path/bindings.tcl"	;# Key event bindings


# Check if a filename was specified on the command line:
if {[llength $argv] > 0} {open_file [lindex $argv 0]}

# Set things up ready for the user to edit the text:
.editor.text mark set insert 0.0
focus .editor.text

set ::status "Ready"

# And from here we just enter the Tcl event loop.
# It'd be nice to attach a Tcl shell REPL to stdin/stdout for controlling the editor from a command shell.
# ...and perhaps also a remote-control FIFO.




