#!/usr/bin/wish8.5

# My (increasingly less) simple Tcl/Tk text editor/idioter.


wm title . Piaf

#puts stderr $argv

#puts stderr $env(PWD)
#puts stderr [info script]
#cd /usr/local/piaf/bin	;# Hmm, better not to [cd], in case a relative filename was given on the command line.
set ::binary_path /usr/local/piaf/bin	;# Or is it better to do something with auto_path?
# lappend auto_path $::binary_path

# TODO: handle command-line arguments (open files, perhaps additional options for e.g. batch running of scripts)


namespace eval ::piaf {}

set ::status "Starting upâ€¦"

source "$::binary_path/settings.tcl"	;# Load system-wide settings first...
catch {source ~/.piaf/settings.tcl}		;# ...then any user-defined settings.

# We use an SQLite database to keep track of recently modified files, collections of files making up projects, etc.
package require sqlite3
sqlite3 ::piaf::database ~/.piaf/data.db
# TODO: create database if necessary?
puts stderr "SQLite database opened, version [::piaf::database version]"

source "$::binary_path/tooltips.tcl"
source "$::binary_path/menus.tcl"
# TODO: toolbar?  Separate file.

frame .editor
pack .editor -side top -expand true -fill both

# TODO: tidy up wrapping option setting.
# Most of the editor happens in this one line, thanks to Tk's great text widget:
text .editor.text -wrap word -undo true -height 10 -width 80
set ::wrap_mode "Word Wrap"

# Scrollbar for the main text (on the left, dammit!):
scrollbar .editor.scrollbar -command [list .editor.text yview]
.editor.text configure -yscrollcommand [list .editor.scrollbar set]

pack .editor.text -side right -expand true -fill both
pack .editor.scrollbar -side left -fill y


# Apply font preference:
.editor.text configure -font $::font
.editor.text configure -spacing1 $::line_padding -spacing3 $::line_padding
# -spacing2 is for wrapped lines, and we kinda want to emphasise that they are just one line, so leave that at 0.

# Apply a colour scheme:
.editor.text configure -background $::background_colour -foreground $::text_colour -selectbackground $::selectbackground_colour -insertbackground $::insertbackground_colour


# Bring in various support functionality:

source "$::binary_path/functions.tcl"	;# Text filters
source "$::binary_path/commands.tcl"	;# Editor command set
source "$::binary_path/find_panel.tcl"	;# Toggleable simple Find panel
source "$::binary_path/unsaved_panel.tcl"	;# Toggleable panel for dealing with unsaved changes
source "$::binary_path/statusbar.tcl"
source "$::binary_path/current_line_highlighting.tcl"	;# Must go before text_modification_tracking!
source "$::binary_path/text_modification_tracking.tcl"	;# Important for detecting unsaved changes, and also includes colouring the "void" beyond EOF differently from the editor text extent.
source "$::binary_path/insert_mark_tracking.tcl"	;# Generating virtual events for motion of the "insert" mark (cursor position)
source "$::binary_path/bindings.tcl"	;# Key event bindings
catch {source ~/.piaf/bindings.tcl}	;# User can override and add their own too

# Apply new grid layout:
# (TODO: remove existing pack calls that are made redundant by this)

set ::main_column 0	;# For when we add some sidebars
# TODO: maybe a row counter variable as well?  IIRC that's how we managed it in TclJACK.
grid columnconfigure . $::main_column -weight 1	;# Main column should fill the width of the window
# "grid slaves ." to find children
grid configure .menubar   -row 0 -column $::main_column -sticky ew
grid configure .editor    -row 1 -column $::main_column -sticky nsew; grid rowconfigure . 1 -weight 1
grid configure .unsaved   -row 2 -column $::main_column -sticky ew
grid configure .search    -row 3 -column $::main_column -sticky ew
grid configure .statusbar -row 4 -column $::main_column -sticky ew

grid forget .unsaved
grid forget .search
# TODO: procs to restore those togglable frames.

# That's it for the GUI layout.


# Check if a filename was specified on the command line:
if {[llength $argv] > 0} {open_file [lindex $argv 0]}

# Set things up ready for the user to edit the text:
.editor.text mark set insert 0.0
focus .editor.text

# (Optionally?) start the Frink server:
start_frinkserver

wm protocol . WM_DELETE_WINDOW quit

set ::status "Ready"

# And from here we just enter the Tcl event loop.
# It'd be nice to attach a Tcl shell REPL to stdin/stdout for controlling the editor from a command shell.
# ...and perhaps also a remote-control FIFO.



